"uniform float opacity;
varying vec3 vLightFront;
#ifdef USE_COLOR
varying vec3 vColor;
#endif

uniform sampler2D shadowMap[ MAX_SHADOWS ];
uniform vec2 shadowMapSize[ MAX_SHADOWS ];
uniform float shadowDarkness[ MAX_SHADOWS ];
uniform float shadowBias[ MAX_SHADOWS ];
varying vec4 vShadowCoord[ MAX_SHADOWS ];
float unpackDepth( const in vec4 rgba_depth ) {
const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );
float depth = dot( rgba_depth, bit_shift );
return depth;
}

void main() {
    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );
    float specularStrength;
    specularStrength = 1.0;
    gl_FragColor.xyz *= vLightFront;
    gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );
    
    #ifdef USE_SHADOWMAP
    float fDepth;
    vec3 shadowColor = vec3( 1.0 );
    for( int i = 0; i < MAX_SHADOWS; i ++ ) {
    vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;
    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
    bool inFrustum = all( inFrustumVec );
    bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
    bool frustumTest = all( frustumTestVec );
    if ( frustumTest ) {
    shadowCoord.z += shadowBias[ i ];
    #if defined( SHADOWMAP_TYPE_PCF )
    float shadow = 0.0;
    const float shadowDelta = 1.0 / 9.0;
    float xPixelOffset = 1.0 / shadowMapSize[ i ].x;
    float yPixelOffset = 1.0 / shadowMapSize[ i ].y;
    float dx0 = -1.25 * xPixelOffset;
    float dy0 = -1.25 * yPixelOffset;
    float dx1 = 1.25 * xPixelOffset;
    float dy1 = 1.25 * yPixelOffset;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );
    if ( fDepth < shadowCoord.z ) shadow += shadowDelta;
    shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );
    #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
    float shadow = 0.0;
    float xPixelOffset = 1.0 / shadowMapSize[ i ].x;
    float yPixelOffset = 1.0 / shadowMapSize[ i ].y;
    float dx0 = -1.0 * xPixelOffset;
    float dy0 = -1.0 * yPixelOffset;
    float dx1 = 1.0 * xPixelOffset;
    float dy1 = 1.0 * yPixelOffset;
    mat3 shadowKernel;
    mat3 depthKernel;
    depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );
    depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );  
    depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );
    depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );
    depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );
    depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );
    depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );
    depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );
    depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );
    vec3 shadowZ = vec3( shadowCoord.z );
    shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));
    shadowKernel[0] *= vec3(0.25);
    shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));
    shadowKernel[1] *= vec3(0.25);
    shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));
    shadowKernel[2] *= vec3(0.25);
    vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );
    shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );
    shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );
    vec4 shadowValues;
    shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );
    shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );
    shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );
    shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );
    shadow = dot( shadowValues, vec4( 1.0 ) );
    shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );
    #else
    vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );
    float fDepth = unpackDepth( rgbaDepth );
    if ( fDepth < shadowCoord.z )
    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );
    #endif
    }
    }
    gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;
    #endif
}"